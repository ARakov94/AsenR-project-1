{
  "name": "DnD 5e Hero & Item Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dnd-items",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000001",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "dnd-items"
    },
    {
      "parameters": {
        "jsCode": "// Extract input from the webhook body\nconst input = $input.first().json.body;\n\nconst characterName = input.characterName || '';\nconst characterClass = input.characterClass || 'Fighter';\nconst characterRace = input.characterRace || 'Human';\nconst characterLevel = input.characterLevel || 1;\nconst spiciness = input.spiciness || 0;\nconst itemCount = input.itemCount || 5;\nconst itemTypes = input.itemTypes || [];\n\n// Determine spiciness instruction\nlet spicyInstruction = '';\nif (spiciness < 25) {\n  spicyInstruction = 'Keep all items completely family-friendly and suitable for all ages. Standard D&D fantasy items.';\n} else if (spiciness < 50) {\n  spicyInstruction = 'Items can have mildly suggestive or cheeky names and descriptions. Think tavern humor - innuendos and playful double meanings, but nothing explicit.';\n} else if (spiciness < 75) {\n  spicyInstruction = 'Items should have clearly suggestive, flirty, or risqué themes. Adult humor is encouraged - think burlesque D&D. Names and descriptions can be provocative but not vulgar.';\n} else {\n  spicyInstruction = 'Items should be boldly adult-themed with explicit humor, provocative descriptions, and unapologetically 18+ content. Be creative and daring with innuendo and adult themes, but maintain a sense of humor and D&D fantasy flavor.';\n}\n\n// Item type filter instruction\nconst typeMap = {\n  weapons: 'weapons (swords, axes, bows, daggers, staves, etc.)',\n  armor: 'armor and shields (plate, chain, leather, shields, helmets, etc.)',\n  potions: 'potions and elixirs',\n  scrolls: 'scrolls, spellbooks, and magical tomes',\n  jewelry: 'jewelry (rings, amulets, necklaces, bracelets, etc.)',\n  trinkets: 'trinkets, curiosities, and talismans',\n  clothing: 'clothing, cloaks, boots, and wearable items',\n  tools: 'tools and utility items',\n  consumables: 'consumable items (food, drinks, throwables, etc.)'\n};\n\nlet itemTypeInstruction = '';\nif (itemTypes.length === 1) {\n  itemTypeInstruction = `\\nIMPORTANT: ALL ${itemCount} items MUST be ${typeMap[itemTypes[0]] || itemTypes[0]}. Do not include other item types.`;\n} else if (itemTypes.length > 1) {\n  const typeNames = itemTypes.map(t => typeMap[t] || t).join(', ');\n  itemTypeInstruction = `\\nIMPORTANT: Items MUST be from these categories ONLY: ${typeNames}. Distribute items roughly evenly across the selected types. Do not include items from other categories.`;\n}\n\nconst nameLine = characterName ? `- Character Name: ${characterName}\\n` : '';\n\nconst userPrompt = `Generate exactly ${itemCount} unique starting items for a new character:\\n\\n${nameLine}- Class: ${characterClass}\\n- Race: ${characterRace}\\n- Level: ${characterLevel}\\n${itemTypeInstruction}\\n\\nSpiciness Level: ${spiciness}/100\\n${spicyInstruction}\\n\\nFor each item provide these JSON fields:\\n- \\\"name\\\": A creative item name\\n- \\\"type\\\": Item category (weapon, armor, potion, trinket, tool, clothing, misc, scroll, ring, amulet, etc.)\\n- \\\"rarity\\\": One of: common, uncommon, rare, very-rare, legendary\\n- \\\"description\\\": A flavorful 1-3 sentence description\\n- \\\"properties\\\": Array of 1-3 mechanical properties or fun effects\\n\\nRules:\\n- Mix item types appropriate for the class (unless a specific type filter is set)\\n- For level 1 characters, most items should be common/uncommon\\n- At least one trinket or personal item with backstory flavor\\n- Items should feel thematic to the class and race\\n\\nRespond with a JSON array of ${itemCount} item objects. No markdown, no code fences.`;\n\nreturn [{\n  json: {\n    userPrompt,\n    characterName,\n    characterClass,\n    spiciness\n  }\n}];"
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000002",
      "name": "Build Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 300]
    },
    {
      "parameters": {
        "text": "={{ $json.userPrompt }}",
        "options": {
          "systemMessage": "You are a creative D&D 5e (2024 rules) item designer. You always respond ONLY with valid JSON arrays. No markdown, no code fences, no explanation text.",
          "maxIterations": 1
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000003",
      "name": "AI Agent - Items",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [710, 300]
    },
    {
      "parameters": {
        "model": "x-ai/grok-3-mini",
        "options": {
          "temperature": 0.9,
          "maxTokens": 4000
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000004",
      "name": "OpenRouter Model - Items",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [710, 500],
      "credentials": {
        "openRouterApi": {
          "id": "YOUR_OPENROUTER_CREDENTIAL_ID",
          "name": "OpenRouter API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse the AI Agent response into items array\nconst aiResponse = $input.first().json.output;\n\nif (!aiResponse) {\n  throw new Error('No response from Items AI Agent');\n}\n\ntry {\n  let cleaned = aiResponse.trim();\n  if (cleaned.startsWith('```json')) cleaned = cleaned.slice(7);\n  if (cleaned.startsWith('```')) cleaned = cleaned.slice(3);\n  if (cleaned.endsWith('```')) cleaned = cleaned.slice(0, -3);\n  cleaned = cleaned.trim();\n\n  const items = JSON.parse(cleaned);\n  const itemsArray = Array.isArray(items) ? items : [items];\n\n  return [{ json: { items: itemsArray } }];\n\n} catch (error) {\n  const match = aiResponse.match(/\\[\\s*\\{[\\s\\S]*\\}\\s*\\]/);\n  if (match) {\n    try {\n      const items = JSON.parse(match[0]);\n      return [{ json: { items } }];\n    } catch (e) {}\n  }\n\n  return [{ json: { items: [{\n    name: 'Mysterious Error Scroll',\n    type: 'scroll',\n    rarity: 'common',\n    description: 'Something went wrong in the magical forge.',\n    properties: ['Try generating again']\n  }] } }];\n}"
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000005",
      "name": "Parse Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json.items) }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type"
              }
            ]
          }
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000006",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1170, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dnd-backstory",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "b2c3d4e5-0001-4000-b000-000000000001",
      "name": "Backstory Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 700],
      "webhookId": "dnd-backstory"
    },
    {
      "parameters": {
        "jsCode": "// Extract input from the webhook body\nconst input = $input.first().json.body;\n\nconst characterClass = input.characterClass || 'Fighter';\nconst characterRace = input.characterRace || 'Human';\nconst characterLevel = input.characterLevel || 1;\nconst elements = input.elements || ['name', 'origin', 'strengths', 'weaknesses', 'personality', 'history', 'goal', 'aspiration'];\n\n// Map elements to detailed descriptions for the prompt\nconst elementDescriptions = {\n  name: 'A lore-appropriate character name fitting the race and class. Use naming conventions from official D&D sourcebooks (e.g., Elvish names for Elves, Nordic-style for Goliaths, Infernal-touched for Tieflings). Provide first name and optional surname or epithet.',\n  origin: 'Where the character comes from — a specific region, city, village, or realm from the Forgotten Realms or D&D multiverse. Describe the place briefly and how it shaped the character. Examples: Waterdeep, Baldur\\'s Gate, Menzoberranzan, a nomadic tribe, a remote monastery.',\n  strengths: 'Exactly 3 strong character traits or abilities that define what the character excels at. These should be personality-driven strengths (e.g., unwavering courage, natural leadership, sharp wit) tied to their class/race background.',\n  weaknesses: 'Exactly 3 character flaws or vulnerabilities that create interesting roleplay opportunities. These should feel real and tied to who the character is (e.g., arrogance, fear of the dark, inability to trust others, reckless impulsiveness).',\n  personality: 'A vivid 2-3 sentence description of the character\\'s personality, demeanor, and how they interact with others. Include quirks, habits, or mannerisms that make them memorable.',\n  history: 'A compelling 3-5 sentence backstory explaining the character\\'s past — key events, turning points, family, mentors, or traumas that led them to become an adventurer. Reference appropriate D&D lore for the race and class.',\n  goal: 'The character\\'s primary life goal or driving motivation — what they are trying to achieve in the grand scheme. This should be specific and tied to their backstory (e.g., avenge a fallen mentor, reclaim an ancestral homeland, break a curse).',\n  aspiration: 'What the character aspires to become or achieve on a personal/spiritual level — their ideal future self or dream. This is more abstract than their goal (e.g., become worthy of a god\\'s blessing, find inner peace, be remembered as a legend).'\n};\n\n// Build the list of requested elements\nconst requestedParts = elements.map(el => {\n  const desc = elementDescriptions[el];\n  if (!desc) return null;\n  return `- \"${el}\": ${desc}`;\n}).filter(Boolean).join('\\n');\n\n// Build format instructions for each element\nconst formatInstructions = elements.map(el => {\n  if (el === 'strengths' || el === 'weaknesses') {\n    return `  \"${el}\": [\"trait1\", \"trait2\", \"trait3\"]`;\n  }\n  return `  \"${el}\": \"string value\"`;\n}).join(',\\n');\n\nconst userPrompt = `Generate a complete character backstory for a D&D 5e (2024 edition) character with the following details:\n\n- Class: ${characterClass}\n- Race: ${characterRace}\n- Level: ${characterLevel}\n\nGenerate ONLY the following elements:\n${requestedParts}\n\nIMPORTANT RULES:\n1. Use official D&D 5e lore from the Forgotten Realms setting. Reference real locations, deities, factions, and cultural details appropriate for the race.\n2. Everything must be internally consistent — the name, origin, history, personality, and goals should all connect logically.\n3. The backstory should reflect the character's class training and racial heritage.\n4. For level ${characterLevel}, the character should feel appropriately experienced (level 1 = novice adventurer, level 5 = seasoned).\n5. Be creative and evocative — make this character feel alive and interesting to roleplay.\n6. \"strengths\" and \"weaknesses\" MUST be JSON arrays of exactly 3 strings each.\n7. All other fields must be strings.\n\nRespond with a JSON object in this exact format (no markdown, no code fences, no extra text):\n{\n${formatInstructions}\n}`;\n\nreturn [{\n  json: {\n    userPrompt,\n    characterClass,\n    characterRace,\n    characterLevel,\n    elements\n  }\n}];"
      },
      "id": "b2c3d4e5-0001-4000-b000-000000000002",
      "name": "Build Backstory Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 700]
    },
    {
      "parameters": {
        "text": "={{ $json.userPrompt }}",
        "options": {
          "systemMessage": "You are an expert D&D 5e lore master and character creator with deep knowledge of the Forgotten Realms, Greyhawk, and the D&D multiverse. You specialize in creating rich, immersive character backstories that are consistent with official D&D lore. You always respond ONLY with valid JSON objects. No markdown, no code fences, no explanation text. Your characters feel alive, with interconnected traits, histories, and motivations.",
          "maxIterations": 1
        }
      },
      "id": "b2c3d4e5-0001-4000-b000-000000000003",
      "name": "AI Agent - Backstory",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [710, 700]
    },
    {
      "parameters": {
        "model": "x-ai/grok-3-mini",
        "options": {
          "temperature": 0.85,
          "maxTokens": 4000
        }
      },
      "id": "b2c3d4e5-0001-4000-b000-000000000004",
      "name": "OpenRouter Model - Backstory",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [710, 900],
      "credentials": {
        "openRouterApi": {
          "id": "YOUR_OPENROUTER_CREDENTIAL_ID",
          "name": "OpenRouter API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse the AI Agent response into backstory object\nconst aiResponse = $input.first().json.output;\n\nif (!aiResponse) {\n  throw new Error('No response from Backstory AI Agent');\n}\n\ntry {\n  let cleaned = aiResponse.trim();\n  // Remove markdown code fences if present\n  if (cleaned.startsWith('```json')) cleaned = cleaned.slice(7);\n  if (cleaned.startsWith('```')) cleaned = cleaned.slice(3);\n  if (cleaned.endsWith('```')) cleaned = cleaned.slice(0, -3);\n  cleaned = cleaned.trim();\n\n  const backstory = JSON.parse(cleaned);\n  return [{ json: backstory }];\n\n} catch (error) {\n  // Try to find a JSON object in the response\n  const match = aiResponse.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    try {\n      const backstory = JSON.parse(match[0]);\n      return [{ json: backstory }];\n    } catch (e) {}\n  }\n\n  // Fallback error response\n  return [{ json: {\n    name: 'Unknown Hero',\n    origin: 'The mists of an unknown realm...',\n    strengths: ['Determination', 'Adaptability', 'Courage'],\n    weaknesses: ['Mysterious past', 'Unknown enemies', 'Self-doubt'],\n    personality: 'A mysterious figure whose story is yet to be written.',\n    history: 'The magical scribe encountered an error while recording this tale. Please try again.',\n    goal: 'To discover their true destiny.',\n    aspiration: 'To become a legend worth remembering.'\n  } }];\n}"
      },
      "id": "b2c3d4e5-0001-4000-b000-000000000005",
      "name": "Parse Backstory",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 700]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type"
              }
            ]
          }
        }
      },
      "id": "b2c3d4e5-0001-4000-b000-000000000006",
      "name": "Respond Backstory",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1170, 700]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [{ "node": "Build Prompt", "type": "main", "index": 0 }]
      ]
    },
    "Build Prompt": {
      "main": [
        [{ "node": "AI Agent - Items", "type": "main", "index": 0 }]
      ]
    },
    "OpenRouter Model - Items": {
      "ai_languageModel": [
        [{ "node": "AI Agent - Items", "type": "ai_languageModel", "index": 0 }]
      ]
    },
    "AI Agent - Items": {
      "main": [
        [{ "node": "Parse Items", "type": "main", "index": 0 }]
      ]
    },
    "Parse Items": {
      "main": [
        [{ "node": "Respond to Webhook", "type": "main", "index": 0 }]
      ]
    },
    "Backstory Webhook": {
      "main": [
        [{ "node": "Build Backstory Prompt", "type": "main", "index": 0 }]
      ]
    },
    "Build Backstory Prompt": {
      "main": [
        [{ "node": "AI Agent - Backstory", "type": "main", "index": 0 }]
      ]
    },
    "OpenRouter Model - Backstory": {
      "ai_languageModel": [
        [{ "node": "AI Agent - Backstory", "type": "ai_languageModel", "index": 0 }]
      ]
    },
    "AI Agent - Backstory": {
      "main": [
        [{ "node": "Parse Backstory", "type": "main", "index": 0 }]
      ]
    },
    "Parse Backstory": {
      "main": [
        [{ "node": "Respond Backstory", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    { "name": "DnD", "id": "1" },
    { "name": "AI", "id": "2" },
    { "name": "Backstory", "id": "3" }
  ]
}
