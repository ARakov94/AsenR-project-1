{
  "name": "DnD 5e Item Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "dnd-items",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000001",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "dnd-items"
    },
    {
      "parameters": {
        "jsCode": "// Extract input from the webhook body\nconst input = $input.first().json.body;\n\nconst characterName = input.characterName || '';\nconst characterClass = input.characterClass || 'Fighter';\nconst characterRace = input.characterRace || 'Human';\nconst characterLevel = input.characterLevel || 1;\nconst spiciness = input.spiciness || 0;\nconst itemCount = input.itemCount || 5;\nconst itemTypes = input.itemTypes || [];\n\n// Determine spiciness instruction\nlet spicyInstruction = '';\nif (spiciness < 25) {\n  spicyInstruction = 'Keep all items completely family-friendly and suitable for all ages. Standard D&D fantasy items.';\n} else if (spiciness < 50) {\n  spicyInstruction = 'Items can have mildly suggestive or cheeky names and descriptions. Think tavern humor - innuendos and playful double meanings, but nothing explicit.';\n} else if (spiciness < 75) {\n  spicyInstruction = 'Items should have clearly suggestive, flirty, or risqué themes. Adult humor is encouraged - think burlesque D&D. Names and descriptions can be provocative but not vulgar.';\n} else {\n  spicyInstruction = 'Items should be boldly adult-themed with explicit humor, provocative descriptions, and unapologetically 18+ content. Be creative and daring with innuendo and adult themes, but maintain a sense of humor and D&D fantasy flavor.';\n}\n\n// Item type filter instruction\nconst typeMap = {\n  weapons: 'weapons (swords, axes, bows, daggers, staves, etc.)',\n  armor: 'armor and shields (plate, chain, leather, shields, helmets, etc.)',\n  potions: 'potions and elixirs',\n  scrolls: 'scrolls, spellbooks, and magical tomes',\n  jewelry: 'jewelry (rings, amulets, necklaces, bracelets, etc.)',\n  trinkets: 'trinkets, curiosities, and talismans',\n  clothing: 'clothing, cloaks, boots, and wearable items',\n  tools: 'tools and utility items',\n  consumables: 'consumable items (food, drinks, throwables, etc.)'\n};\n\nlet itemTypeInstruction = '';\nif (itemTypes.length === 1) {\n  itemTypeInstruction = `\\nIMPORTANT: ALL ${itemCount} items MUST be ${typeMap[itemTypes[0]] || itemTypes[0]}. Do not include other item types.`;\n} else if (itemTypes.length > 1) {\n  const typeNames = itemTypes.map(t => typeMap[t] || t).join(', ');\n  itemTypeInstruction = `\\nIMPORTANT: Items MUST be from these categories ONLY: ${typeNames}. Distribute items roughly evenly across the selected types. Do not include items from other categories.`;\n}\n\nconst nameLine = characterName ? `- Character Name: ${characterName}\\n` : '';\n\nconst userPrompt = `Generate exactly ${itemCount} unique starting items for a new character:\\n\\n${nameLine}- Class: ${characterClass}\\n- Race: ${characterRace}\\n- Level: ${characterLevel}\\n${itemTypeInstruction}\\n\\nSpiciness Level: ${spiciness}/100\\n${spicyInstruction}\\n\\nFor each item provide these JSON fields:\\n- \\\"name\\\": A creative item name\\n- \\\"type\\\": Item category (weapon, armor, potion, trinket, tool, clothing, misc, scroll, ring, amulet, etc.)\\n- \\\"rarity\\\": One of: common, uncommon, rare, very-rare, legendary\\n- \\\"description\\\": A flavorful 1-3 sentence description\\n- \\\"properties\\\": Array of 1-3 mechanical properties or fun effects\\n\\nRules:\\n- Mix item types appropriate for the class (unless a specific type filter is set)\\n- For level 1 characters, most items should be common/uncommon\\n- At least one trinket or personal item with backstory flavor\\n- Items should feel thematic to the class and race\\n\\nRespond with a JSON array of ${itemCount} item objects. No markdown, no code fences.`;\n\nreturn [{\n  json: {\n    userPrompt,\n    characterName,\n    characterClass,\n    spiciness\n  }\n}];"
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000002",
      "name": "Build Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 300]
    },
    {
      "parameters": {
        "text": "={{ $json.userPrompt }}",
        "options": {
          "systemMessage": "You are a creative D&D 5e (2024 rules) item designer. You always respond ONLY with valid JSON arrays. No markdown, no code fences, no explanation text.",
          "maxIterations": 1
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000003",
      "name": "AI Agent - Items",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [710, 300]
    },
    {
      "parameters": {
        "model": "x-ai/grok-3-mini",
        "options": {
          "temperature": 0.9,
          "maxTokens": 4000
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000004",
      "name": "OpenRouter Model - Items",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [710, 500],
      "credentials": {
        "openRouterApi": {
          "id": "YOUR_OPENROUTER_CREDENTIAL_ID",
          "name": "OpenRouter API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse the AI Agent response into items array\nconst aiResponse = $input.first().json.output;\n\nif (!aiResponse) {\n  throw new Error('No response from Items AI Agent');\n}\n\ntry {\n  let cleaned = aiResponse.trim();\n  if (cleaned.startsWith('```json')) cleaned = cleaned.slice(7);\n  if (cleaned.startsWith('```')) cleaned = cleaned.slice(3);\n  if (cleaned.endsWith('```')) cleaned = cleaned.slice(0, -3);\n  cleaned = cleaned.trim();\n\n  const items = JSON.parse(cleaned);\n  const itemsArray = Array.isArray(items) ? items : [items];\n\n  return [{ json: { items: itemsArray } }];\n\n} catch (error) {\n  const match = aiResponse.match(/\\[\\s*\\{[\\s\\S]*\\}\\s*\\]/);\n  if (match) {\n    try {\n      const items = JSON.parse(match[0]);\n      return [{ json: { items } }];\n    } catch (e) {}\n  }\n\n  return [{ json: { items: [{\n    name: 'Mysterious Error Scroll',\n    type: 'scroll',\n    rarity: 'common',\n    description: 'Something went wrong in the magical forge.',\n    properties: ['Try generating again']\n  }] } }];\n}"
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000005",
      "name": "Parse Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 300]
    },
    {
      "parameters": {
        "jsCode": "// Split items into individual outputs — one per item\n// Each output contains the item data + a dedicated image prompt request\n// n8n will automatically loop AI Agent - Images for each output\nconst items = $input.first().json.items;\n\nreturn items.map((item, index) => ({\n  json: {\n    itemIndex: index,\n    item: item,\n    totalItems: items.length,\n    imagePromptText: `Describe this single D&D fantasy item visually for an AI image generator.\\n\\nItem: \"${item.name}\"\\nType: ${item.type || 'magical item'}\\nRarity: ${item.rarity || 'common'}\\nDescription: ${item.description || ''}\\n\\nRespond with ONLY a JSON object (no array, no markdown, no code fences):\\n{\"imagePrompt\": \"your 15-25 word visual description here\"}\\n\\nThe imagePrompt must describe the item\\'s physical appearance: shape, material, color, magical glow, engravings, etc. End with \\\"dark fantasy style, detailed illustration, game icon art, no text\\\".\\n\\nExample: {\"imagePrompt\": \"ornate steel warhammer with glowing red runes, dragon-head pommel, leather grip, dark fantasy style, detailed illustration, game icon art, no text\"}`\n  }\n}));"
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000007",
      "name": "Split Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1170, 300]
    },
    {
      "parameters": {
        "text": "={{ $json.imagePromptText }}",
        "options": {
          "systemMessage": "You are a visual description specialist for fantasy items. You respond ONLY with a single valid JSON object like {\"imagePrompt\": \"...\"}. No arrays, no markdown, no code fences, no explanation. The imagePrompt must be a unique, vivid 15-25 word English description of the specific item's appearance.",
          "maxIterations": 1
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000008",
      "name": "AI Agent - Images",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [1400, 300]
    },
    {
      "parameters": {
        "model": "x-ai/grok-3-mini",
        "options": {
          "temperature": 0.7,
          "maxTokens": 300
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000009",
      "name": "OpenRouter Model - Images",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [1400, 500],
      "credentials": {
        "openRouterApi": {
          "id": "YOUR_OPENROUTER_CREDENTIAL_ID",
          "name": "OpenRouter API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Collect all split items and their AI-generated image prompts\n// n8n ran AI Agent - Images once per item, now we merge them all back\nconst splitItems = $('Split Items').all();\nconst imageOutputs = $('AI Agent - Images').all();\n\nconst finalItems = splitItems.map((splitItem, index) => {\n  const item = splitItem.json.item;\n  let imagePrompt = '';\n\n  try {\n    let output = imageOutputs[index].json.output || '';\n    // Clean markdown fences\n    output = output.trim();\n    if (output.startsWith('```json')) output = output.slice(7);\n    if (output.startsWith('```')) output = output.slice(3);\n    if (output.endsWith('```')) output = output.slice(0, -3);\n    output = output.trim();\n\n    const parsed = JSON.parse(output);\n    imagePrompt = parsed.imagePrompt || '';\n  } catch (e) {\n    // Try regex extraction\n    try {\n      const raw = imageOutputs[index].json.output || '';\n      const match = raw.match(/\"imagePrompt\"\\s*:\\s*\"([^\"]+)\"/);\n      if (match) imagePrompt = match[1];\n    } catch (e2) {}\n  }\n\n  // Fallback: generate from item data\n  if (!imagePrompt) {\n    imagePrompt = `${item.name}, ${item.type || 'magical item'}, ${item.rarity || 'common'} quality, dark fantasy style, detailed illustration, game icon art, no text`;\n  }\n\n  return {\n    ...item,\n    imagePrompt\n  };\n});\n\nreturn [{ json: { items: finalItems } }];"
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000010",
      "name": "Merge Items & Images",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1630, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json.items) }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              },
              {
                "name": "Access-Control-Allow-Headers",
                "value": "Content-Type"
              }
            ]
          }
        }
      },
      "id": "d1a2b3c4-0001-4000-a000-000000000006",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1860, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [{ "node": "Build Prompt", "type": "main", "index": 0 }]
      ]
    },
    "Build Prompt": {
      "main": [
        [{ "node": "AI Agent - Items", "type": "main", "index": 0 }]
      ]
    },
    "OpenRouter Model - Items": {
      "ai_languageModel": [
        [{ "node": "AI Agent - Items", "type": "ai_languageModel", "index": 0 }]
      ]
    },
    "AI Agent - Items": {
      "main": [
        [{ "node": "Parse Items", "type": "main", "index": 0 }]
      ]
    },
    "Parse Items": {
      "main": [
        [{ "node": "Split Items", "type": "main", "index": 0 }]
      ]
    },
    "Split Items": {
      "main": [
        [{ "node": "AI Agent - Images", "type": "main", "index": 0 }]
      ]
    },
    "OpenRouter Model - Images": {
      "ai_languageModel": [
        [{ "node": "AI Agent - Images", "type": "ai_languageModel", "index": 0 }]
      ]
    },
    "AI Agent - Images": {
      "main": [
        [{ "node": "Merge Items & Images", "type": "main", "index": 0 }]
      ]
    },
    "Merge Items & Images": {
      "main": [
        [{ "node": "Respond to Webhook", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    { "name": "DnD", "id": "1" },
    { "name": "AI", "id": "2" }
  ]
}
